'use client';
import React, { createContext, Component, createElement, useContext, useState, useMemo, forwardRef } from 'react';

const ErrorBoundaryContext = /*#__PURE__*/createContext(null);

const initialState = {
  didCatch: false,
  error: null
};
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: true,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;

    // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,
    // we'd end up resetting the error boundary immediately.
    // This would likely trigger a second error to be thrown.
    // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.

    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = /*#__PURE__*/createElement(FallbackComponent, props);
      } else if (fallback !== undefined) {
        childToRender = fallback;
      } else {
        throw error;
      }
    }
    return /*#__PURE__*/createElement(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
}
function hasArrayChanged() {
  let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return a.length !== b.length || a.some((item, index) => !Object.is(item, b[index]));
}

function ErrorPage(props) {
  return /*#__PURE__*/React.createElement("div", {
    style: {
      minHeight: "100vh",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      fontFamily: "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif",
      padding: "20px"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      backgroundColor: "#ffffff",
      borderRadius: "16px",
      boxShadow: "0 20px 50px rgba(0, 0, 0, 0.15)",
      padding: "40px",
      maxWidth: "800px",
      width: "100%",
      maxHeight: "80vh",
      overflow: "auto"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      textAlign: "center",
      marginBottom: "32px",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      gap: "16px"
    }
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      fontSize: "32px"
    }
  }, "\u26A0\uFE0F"), /*#__PURE__*/React.createElement("h1", {
    style: {
      color: "#e53e3e",
      fontSize: "32px",
      fontWeight: "700",
      margin: "0"
    }
  }, "Something went wrong")), /*#__PURE__*/React.createElement("div", {
    style: {
      marginBottom: "24px"
    }
  }, /*#__PURE__*/React.createElement("h2", {
    style: {
      color: "#2d3748",
      fontSize: "18px",
      fontWeight: "600",
      marginBottom: "12px",
      display: "flex",
      alignItems: "center",
      gap: "8px"
    }
  }, /*#__PURE__*/React.createElement("span", null, "\uD83D\uDD34"), "Error Message"), /*#__PURE__*/React.createElement("div", {
    style: {
      backgroundColor: "#fed7d7",
      border: "1px solid #feb2b2",
      borderRadius: "8px",
      padding: "16px",
      color: "#742a2a",
      fontSize: "14px",
      fontWeight: "500",
      textAlign: "left",
      overflow: "auto",
      whiteSpace: "pre"
    }
  }, props.error.message || "No error message available")), props.error.stack && /*#__PURE__*/React.createElement("div", null, /*#__PURE__*/React.createElement("h2", {
    style: {
      color: "#2d3748",
      fontSize: "18px",
      fontWeight: "600",
      marginBottom: "12px",
      display: "flex",
      alignItems: "center",
      gap: "8px"
    }
  }, /*#__PURE__*/React.createElement("span", null, "\uD83D\uDCCB"), "Stack Trace"), /*#__PURE__*/React.createElement("div", {
    style: {
      backgroundColor: "#f7fafc",
      border: "1px solid #e2e8f0",
      borderRadius: "8px",
      padding: "16px",
      fontSize: "12px",
      fontFamily: "Monaco, Menlo, 'Ubuntu Mono', monospace",
      color: "#4a5568",
      lineHeight: "1.5",
      overflow: "auto",
      maxHeight: "300px",
      whiteSpace: "pre"
    }
  }, props.error.stack))));
}
function onError(error, info) {
  if (window.sendError) {
    const errorWithComponentStack = error;
    errorWithComponentStack.componentStack = info.componentStack;
    window.sendError(errorWithComponentStack);
  }
}
function ErrorBoundaryReporter(_ref) {
  let {
    children
  } = _ref;
  return /*#__PURE__*/React.createElement(ErrorBoundary, {
    FallbackComponent: props => /*#__PURE__*/React.createElement(ErrorPage, {
      error: props.error
    }),
    onError: onError
  }, children);
}

function assertErrorBoundaryContext(value) {
  if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") {
    throw new Error("ErrorBoundaryContext not found");
  }
}

function useErrorBoundary() {
  const context = useContext(ErrorBoundaryContext);
  assertErrorBoundaryContext(context);
  const [state, setState] = useState({
    error: null,
    hasError: false
  });
  const memoized = useMemo(() => ({
    resetBoundary: () => {
      context.resetErrorBoundary();
      setState({
        error: null,
        hasError: false
      });
    },
    showBoundary: error => setState({
      error,
      hasError: true
    })
  }), [context.resetErrorBoundary]);
  if (state.hasError) {
    throw state.error;
  }
  return memoized;
}

function withErrorBoundary(component, errorBoundaryProps) {
  const Wrapped = /*#__PURE__*/forwardRef((props, ref) => /*#__PURE__*/createElement(ErrorBoundary, errorBoundaryProps, /*#__PURE__*/createElement(component, {
    ...props,
    ref
  })));

  // Format for display in DevTools
  const name = component.displayName || component.name || "Unknown";
  Wrapped.displayName = "withErrorBoundary(".concat(name, ")");
  return Wrapped;
}

export { ErrorBoundaryReporter as ErrorBoundary, ErrorBoundaryContext, ErrorPage, ErrorBoundary as RawErrorBoundary, ErrorBoundaryReporter as default, useErrorBoundary, withErrorBoundary };
